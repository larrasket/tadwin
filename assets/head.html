<!DOCTYPE html>
<html>
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Arimo:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
  <meta name="theme-color" content="#ffffff">
  <meta charset="utf-8">
  <meta name="theme-color" content="#ffffff">
  <meta name="viewport" content= "width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style/toc.css">
  <link rel="stylesheet" href="/style/tufte.css">
  <link rel="stylesheet" href="/style/main.css">




  <script async data-id="101390423" src= "//static.getclicky.com/js"></script> <noscript>
  <p><img alt="Clicky" width="1" height="1" src= "//in.getclicky.com/101390423ns.gif"></p></noscript>

<script>
// Stack Page Formatter - Apply inline layout to specific pages
(function() {
  'use strict';
  
  // Check if current page should have the formatting applied
  function shouldApplyFormatting() {
    const path = window.location.pathname;
    
    // Check if path matches our target patterns
    return path === '/stack' || 
           path === '/stack.html' || 
           path.startsWith('/sh/');
  }
  
  // Only proceed if we're on a target page
  if (!shouldApplyFormatting()) {
    return;
  }
  
  // Add CSS styles
  function addStyles() {
    const style = document.createElement('style');
    style.textContent = `
      /* Basic styling for entries */
      .outline-3 {
        margin-bottom: 1.5em;
        line-height: 1.5;
      }

      /* Style for reconstructed single paragraph */
      .entry-paragraph {
        margin: 0;
        line-height: 1.5;
        direction: inherit;
        unicode-bidi: plaintext;
      }

      /* Style for date - gray and nice */
      .entry-date {
        color: #666;
        font-size: 0.9em;
        margin-right: 0.5em;
      }

      /* Style for tag at end - gray and in parentheses */
      .entry-tag {
        display: inline !important;
        color: #666;
        margin-left: 0.5em;
      }

      /* Ensure all children stay inline */
      .entry-tag * {
        display: inline !important;
      }

      /* Override any existing tag styles */
      .entry-tag p,
      .entry-tag div {
        display: inline !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      /* Hide block elements that will be moved */
      .outline-3 .moved-block {
        display: block;
        margin: 0.5em 0;
      }
    `;
    document.head.appendChild(style);
  }
  
  // Apply the formatting transformation
  function applyFormatting() {
    // Process each entry
    const entries = document.querySelectorAll('.outline-3');
    
    entries.forEach((entry, index) => {
      // Extract components
      const h3 = entry.querySelector('h3');
      const notes = entry.querySelector('.notes');
      const outlineText = entry.querySelector('.outline-text-3');
      const tag = entry.querySelector('.tag');
      
      if (!h3 || !outlineText) return;
      
      // Get title text (preserve any TODO/DONE prefixes and links)
      let titleText = h3.innerHTML;
      
      // Get timestamp
      let timestampText = '';
      if (notes) {
        const timestamp = notes.querySelector('.timestamp');
        if (timestamp) {
          timestampText = timestamp.textContent;
        }
      }
      
      // Get content paragraphs (excluding notes and tag)
      const contentParagraphs = [];
      const blockElements = [];
      
      Array.from(outlineText.children).forEach(child => {
        if (child.classList.contains('notes') || child.classList.contains('tag')) {
          return; // Skip these
        }
        
        if (child.tagName === 'P') {
          contentParagraphs.push(child.innerHTML);
        } else if (child.tagName === 'UL' || child.tagName === 'OL' || 
                   child.tagName === 'BLOCKQUOTE' || child.tagName === 'PRE' ||
                   child.tagName === 'DL' || child.classList.contains('epigraph')) {
          blockElements.push(child.outerHTML);
        } else if (child.tagName === 'DIV' && child.classList.contains('epigraph')) {
          blockElements.push(child.outerHTML);
        }
      });
      
      // Get tag HTML (preserve links and formatting)
      let tagHtml = '';
      if (tag) {
        tagHtml = tag.outerHTML;
      }
      
      // Construct the new single paragraph
      let newContent = '';
      
      // Add date at the start (gray)
      if (timestampText) {
        newContent += '<span class="entry-date">' + timestampText + '</span>';
      }
      
      // Add title with emdash
      newContent += titleText + ' â€” ';
      
      // Add content paragraphs
      newContent += contentParagraphs.join(' ');
      
      // Add tag at the end in parentheses (preserve HTML but force inline)
      if (tagHtml) {
        // Extract just the inner content and wrap it properly
        let tagContent = tag.innerHTML;
        newContent += ' <span class="entry-tag">(' + tagContent + ')</span>';
      }
      
      // Create new paragraph element
      const newParagraph = document.createElement('p');
      newParagraph.className = 'entry-paragraph';
      newParagraph.innerHTML = newContent;
      
      // Clear the entry and add the new paragraph
      entry.innerHTML = '';
      entry.appendChild(newParagraph);
      
      // Add any block elements after the paragraph
      blockElements.forEach(blockHtml => {
        const blockDiv = document.createElement('div');
        blockDiv.className = 'moved-block';
        blockDiv.innerHTML = blockHtml;
        entry.appendChild(blockDiv);
      });
      
      // Add separator after each entry (except the last one)
      if (index < entries.length - 1) {
        const separator = document.createElement('hr');
        separator.style.margin = '1em 0';
        separator.style.border = 'none';
        separator.style.borderTop = '1px solid #ccc';
        entry.appendChild(separator);
      }
    });
  }
  
  // Initialize when DOM is ready
  function init() {
    addStyles();
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', applyFormatting);
    } else {
      applyFormatting();
    }
  }
  
  // Start the initialization
  init();
})();
</script>



</head>
<body>
</body>
</html>
